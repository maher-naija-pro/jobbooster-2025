# Authentication Feature Architecture

## Overview
This document outlines the technical architecture and implementation details for the Authentication system in JobBooster 2025, providing secure user management, session handling, and data persistence using Supabase as the backend-as-a-service platform with Prisma ORM for type-safe database operations.

**Key Architecture Principle**: The system supports anonymous access to the main application interface, with authentication only required for specific features like CV analysis. This is implemented through a modal-based authentication flow that preserves user context and form data.

## System Architecture

### Anonymous Access Architecture
```
┌─────────────────────────────────────────────────────────────────┐
│                    Anonymous User Flow                        │
├─────────────────────────────────────────────────────────────────┤
│  • Access main page without authentication                    │
│  • Upload CV files (stored temporarily)                      │
│  • Input job descriptions                                     │
│  • Preview interface and features   
generate mail or generate lettter user can use them without auth                     │
│  • Click "Analyze CV" → Authentication Modal                 │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Authentication Modal                        │
├─────────────────────────────────────────────────────────────────┤
│  • Quick registration/login options                           │
│  • OAuth providers (Google,)                │

│  • Preserve form data and context                             │
│  • Redirect to CV analysis after authentication               │
└─────────────────────────────────────────────────────────────────┘
```

### High-Level Architecture
```
┌─────────────────────────────────────────────────────────────────┐
│                    Frontend (Next.js 15.5.2)                   │
├─────────────────────────────────────────────────────────────────┤
│  • React 19.1.0 Components                                   │
│  • TypeScript for Type Safety                                 │
│  • Tailwind CSS for Styling                                   │
│  • Supabase Client Integration                                │
│  • Prisma ORM for Database Operations                        │
│  • Server-Side Rendering (SSR) Support                       │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Authentication Layer                        │
├─────────────────────────────────────────────────────────────────┤
│  • Supabase Auth Client                                       │
│  • JWT Token Management                                       │
│  • Session Management                                         │
│  • Middleware for Route Protection                            │
│  • Cookie-based Session Storage                               │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                    API Layer (Next.js API Routes)              │
├─────────────────────────────────────────────────────────────────┤
│  • /api/auth/login - User authentication                      │
│  • /api/auth/register - User registration                     │
│  • /api/auth/logout - Session termination                     │
│  • /api/auth/refresh - Token refresh                          │
│  • /api/user/profile - Profile management                     │
│  • /api/user/preferences - User preferences                   │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Supabase Backend                           │
├─────────────────────────────────────────────────────────────────┤
│  • PostgreSQL Database                                        │
│  • Row Level Security (RLS)                                   │
│  • Real-time Subscriptions                                    │
│  • File Storage (Avatars, CVs)                               │
│  • Edge Functions                                             │
│  • Prisma ORM Integration                                     │
│  • Type-safe Database Queries                                 │
└─────────────────────────────────────────────────────────────────┘
```

## Core Components Architecture

### 1. Authentication Client Setup

#### Prisma ORM Configuration
```typescript
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Profile {
  id          String   @id @default(cuid())
  userId      String   @unique @map("user_id")
  email       String   @unique
  fullName    String?  @map("full_name")
  username    String?  @unique
  avatarUrl   String?  @map("avatar_url")
  preferences Json     @default("{}")
  subscription Json    @default("{\"plan\": \"free\"}")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  userSessions    UserSession[]
  userActivities  UserActivity[]
  cvData          CvData[]
  generatedContent GeneratedContent[]

  @@map("profiles")
}

model UserSession {
  id           String   @id @default(cuid())
  userId       String   @map("user_id")
  sessionToken String   @unique @map("session_token")
  deviceInfo   Json?    @map("device_info")
  ipAddress    String?  @map("ip_address")
  userAgent    String?  @map("user_agent")
  createdAt    DateTime @default(now()) @map("created_at")
  expiresAt    DateTime @map("expires_at")
  lastActivity DateTime @default(now()) @map("last_activity")

  // Relations
  profile Profile @relation(fields: [userId], references: [userId], onDelete: Cascade)

  @@map("user_sessions")
}

model UserActivity {
  id           String   @id @default(cuid())
  userId       String   @map("user_id")
  action       String
  resourceType String?  @map("resource_type")
  resourceId   String?  @map("resource_id")
  metadata     Json?
  ipAddress    String?  @map("ip_address")
  userAgent    String?  @map("user_agent")
  createdAt    DateTime @default(now()) @map("created_at")

  // Relations
  profile Profile @relation(fields: [userId], references: [userId], onDelete: Cascade)

  @@map("user_activity")
}

model CvData {
  id               String   @id @default(cuid())
  userId           String   @map("user_id")
  filename         String
  fileSize         Int?     @map("file_size")
  filePath         String?  @map("file_path")
  uploadDate       DateTime @default(now()) @map("upload_date")
  processedContent String?  @map("processed_content")
  experience       Json?
  education        Json?
  skills           Json?
  status           String   @default("processing")
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @updatedAt @map("updated_at")

  // Relations
  profile           Profile            @relation(fields: [userId], references: [userId], onDelete: Cascade)
  generatedContent  GeneratedContent[]

  @@map("cv_data")
}

model GeneratedContent {
  id           String   @id @default(cuid())
  userId       String   @map("user_id")
  cvId         String?  @map("cv_id")
  contentType  String   @map("content_type")
  content      String
  language     String
  jobAnalysis  Json?    @map("job_analysis")
  metadata     Json     @default("{}")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  // Relations
  profile Profile @relation(fields: [userId], references: [userId], onDelete: Cascade)
  cvData  CvData? @relation(fields: [cvId], references: [id], onDelete: SetNull)

  @@map("generated_content")
}
```

#### Prisma Client Setup
```typescript
// lib/prisma.ts
import { PrismaClient } from '@prisma/client'

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}

export const prisma = globalForPrisma.prisma ?? new PrismaClient()

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma

// lib/prisma-server.ts
import { PrismaClient } from '@prisma/client'

export async function createPrismaClient() {
  return new PrismaClient({
    datasources: {
      db: {
        url: process.env.DATABASE_URL,
      },
    },
  })
}
```

#### Supabase Client Configuration
```typescript
// utils/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}

// utils/supabase/server.ts
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

export async function createClient() {
  const cookieStore = await cookies()
  
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // Server Component context - can be ignored with middleware
          }
        },
      },
    }
  )
}
```

#### Middleware Configuration with Anonymous Access Support
```typescript
// middleware.ts
import { type NextRequest } from 'next/server'
import { updateSession } from '@/utils/supabase/middleware'

export async function middleware(request: NextRequest) {
  // Allow anonymous access to main page and public routes
  const { pathname } = request.nextUrl
  
  // Public routes that don't require authentication
  const publicRoutes = [
    '/',
    '/about',
    '/pricing',
    '/contact',
    '/api/health',
    '/api/public'
  ]
  
  // Check if current route is public
  const isPublicRoute = publicRoutes.some(route => 
    pathname === route || pathname.startsWith(route + '/')
  )
  
  // For public routes, just update session without requiring auth
  if (isPublicRoute) {
    return await updateSession(request, { requireAuth: false })
  }
  
  // For protected routes, require authentication
  return await updateSession(request, { requireAuth: true })
}

export const config = {
  matcher: [
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
  ],
}

// utils/supabase/middleware.ts
import { createServerClient } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'

interface UpdateSessionOptions {
  requireAuth?: boolean
}

export async function updateSession(
  request: NextRequest, 
  options: UpdateSessionOptions = { requireAuth: true }
) {
  let supabaseResponse = NextResponse.next({ request })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll()
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) => 
            request.cookies.set(name, value)
          )
          supabaseResponse = NextResponse.next({ request })
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          )
        },
      },
    }
  )

  // Refresh auth token
  const { data: { user } } = await supabase.auth.getUser()
  
  // If authentication is required and user is not authenticated, redirect to login
  if (options.requireAuth && !user) {
    const loginUrl = new URL('/auth/login', request.url)
    loginUrl.searchParams.set('redirectTo', request.nextUrl.pathname)
    return NextResponse.redirect(loginUrl)
  }
  
  return supabaseResponse
}
```

### 2. Authentication Components

#### Authentication Modal Component
```typescript
// components/auth/auth-modal.tsx
interface AuthModalProps {
  isOpen: boolean
  onClose: () => void
  onSuccess: (user: User) => void
  onError?: (error: string) => void
  mode?: 'login' | 'signup' | 'both'
  preserveData?: {
    cvFile?: File
    jobDescription?: string
    language?: string
  }
}

export function AuthModal({ 
  isOpen, 
  onClose, 
  onSuccess, 
  onError,
  mode = 'both',
  preserveData 
}: AuthModalProps) {
  const [currentMode, setCurrentMode] = useState<'login' | 'signup'>(mode === 'both' ? 'signup' : mode)
  const [isLoading, setIsLoading] = useState(false)

  const handleAuthSuccess = async (user: User) => {
    // Restore preserved data after authentication
    if (preserveData) {
      await restoreUserData(user.id, preserveData)
    }
    onSuccess(user)
    onClose()
  }

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-md">
        <DialogHeader>
          <DialogTitle>
            {currentMode === 'login' ? 'Sign In' : 'Create Account'}
          </DialogTitle>
          <DialogDescription>
            {currentMode === 'login' 
              ? 'Sign in to analyze your CV and generate personalized content'
              : 'Create an account to get started with CV analysis'
            }
          </DialogDescription>
        </DialogHeader>
        
        <div className="space-y-4">
          {/* Quick OAuth Options */}
          <div className="grid grid-cols-2 gap-2">
            <Button variant="outline" onClick={() => handleOAuth('google')}>
              <GoogleIcon className="w-4 h-4 mr-2" />
              Google
            </Button>

          </div>
          
          <div className="relative">
            <div className="absolute inset-0 flex items-center">
              <span className="w-full border-t" />
            </div>
            <div className="relative flex justify-center text-xs uppercase">
              <span className="bg-background px-2 text-muted-foreground">
                Or continue with email
              </span>
            </div>
          </div>
          
          {/* Email/Password Form */}
          <AuthForm 
            mode={currentMode}
            onSuccess={handleAuthSuccess}
            onError={onError}
          />
          
          {/* Mode Toggle */}
          <div className="text-center text-sm">
            {currentMode === 'login' ? (
              <>
                Don't have an account?{' '}
                <Button 
                  variant="link" 
                  className="p-0 h-auto"
                  onClick={() => setCurrentMode('signup')}
                >
                  Sign up
                </Button>
              </>
            ) : (
              <>
                Already have an account?{' '}
                <Button 
                  variant="link" 
                  className="p-0 h-auto"
                  onClick={() => setCurrentMode('login')}
                >
                  Sign in
                </Button>
              </>
            )}
          </div>
        </div>
      </DialogContent>
    </Dialog>
  )
}
```

#### Login/Signup Form Component
```typescript
// components/auth/auth-form.tsx
interface AuthFormProps {
  mode: 'login' | 'signup'
  onSuccess?: (user: User) => void
  onError?: (error: string) => void
}

interface AuthFormData {
  email: string
  password: string
  confirmPassword?: string
  fullName?: string
  acceptTerms?: boolean
}

export function AuthForm({ mode, onSuccess, onError }: AuthFormProps) {
  const [formData, setFormData] = useState<AuthFormData>({
    email: '',
    password: '',
    confirmPassword: '',
    fullName: '',
    acceptTerms: false
  })
  
  const [isLoading, setIsLoading] = useState(false)
  const [errors, setErrors] = useState<Partial<AuthFormData>>({})

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setIsLoading(true)
    setErrors({})

    try {
      if (mode === 'signup') {
        await handleSignup(formData)
      } else {
        await handleLogin(formData)
      }
      onSuccess?.()
    } catch (error) {
      onError?.(error.message)
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      {/* Form fields */}
    </form>
  )
}
```

#### User Profile Component
```typescript
// components/user/user-profile.tsx
interface UserProfileProps {
  user: User
  onUpdate?: (profile: UserProfile) => void
}

interface UserProfile {
  id: string
  email: string
  fullName: string
  username: string
  avatarUrl?: string
  preferences: UserPreferences
  subscription: SubscriptionInfo
  createdAt: Date
  updatedAt: Date
}

export function UserProfile({ user, onUpdate }: UserProfileProps) {
  const [profile, setProfile] = useState<UserProfile | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [isUpdating, setIsUpdating] = useState(false)

  const loadProfile = useCallback(async () => {
    try {
      setIsLoading(true)
      // Using Prisma for type-safe database operations
      const profile = await prisma.profile.findUnique({
        where: { userId: user.id },
        include: {
          userSessions: {
            where: { expiresAt: { gt: new Date() } },
            orderBy: { lastActivity: 'desc' },
            take: 5
          },
          userActivities: {
            orderBy: { createdAt: 'desc' },
            take: 10
          }
        }
      })

      if (profile) {
        setProfile(profile)
      }
    } catch (error) {
      console.error('Error loading profile:', error)
    } finally {
      setIsLoading(false)
    }
  }, [user.id])

  const updateProfile = async (updates: Partial<UserProfile>) => {
    try {
      setIsUpdating(true)
      // Using Prisma for type-safe database operations
      const updatedProfile = await prisma.profile.update({
        where: { userId: user.id },
        data: {
          ...updates,
          updatedAt: new Date()
        },
        include: {
          userSessions: {
            where: { expiresAt: { gt: new Date() } },
            orderBy: { lastActivity: 'desc' },
            take: 5
          },
          userActivities: {
            orderBy: { createdAt: 'desc' },
            take: 10
          }
        }
      })

      setProfile(updatedProfile)
      onUpdate?.(updatedProfile)
    } catch (error) {
      console.error('Error updating profile:', error)
    } finally {
      setIsUpdating(false)
    }
  }

  return (
    <div className="max-w-2xl mx-auto p-6">
      {/* Profile form */}
    </div>
  )
}
```

### 3. Database Schema Architecture

#### Core Tables
```sql
-- User profiles table
CREATE TABLE profiles (
  id UUID REFERENCES auth.users ON DELETE CASCADE PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  full_name TEXT,
  username TEXT UNIQUE,
  avatar_url TEXT,
  preferences JSONB DEFAULT '{
    "language": "en",
    "timezone": "UTC",
    "notifications": {
      "email": true,
      "push": false,
      "marketing": false
    },
    "privacy": {
      "profileVisibility": "private",
      "dataRetention": 365
    }
  }',
  subscription JSONB DEFAULT '{
    "plan": "free",
    "features": ["basic_cv_analysis", "cover_letter_generation"]
  }',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- User sessions for analytics
CREATE TABLE user_sessions (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users ON DELETE CASCADE NOT NULL,
  session_token TEXT UNIQUE NOT NULL,
  device_info JSONB,
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
  last_activity TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- User activity logs
CREATE TABLE user_activity (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users ON DELETE CASCADE NOT NULL,
  action TEXT NOT NULL,
  resource_type TEXT,
  resource_id UUID,
  metadata JSONB,
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- CV data linked to users
CREATE TABLE cv_data (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users ON DELETE CASCADE NOT NULL,
  filename TEXT NOT NULL,
  file_size INTEGER,
  file_path TEXT,
  upload_date TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  processed_content TEXT,
  experience JSONB,
  education JSONB,
  skills JSONB,
  status TEXT DEFAULT 'processing' CHECK (status IN ('processing', 'completed', 'failed')),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Generated content linked to users
CREATE TABLE generated_content (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users ON DELETE CASCADE NOT NULL,
  cv_id UUID REFERENCES cv_data(id) ON DELETE SET NULL,
  content_type TEXT NOT NULL CHECK (content_type IN ('cover_letter', 'email', 'cv_recommendations')),
  content TEXT NOT NULL,
  language TEXT NOT NULL,
  job_analysis JSONB,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

#### Row Level Security (RLS) Policies
```sql
-- Enable RLS on all tables
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_activity ENABLE ROW LEVEL SECURITY;
ALTER TABLE cv_data ENABLE ROW LEVEL SECURITY;
ALTER TABLE generated_content ENABLE ROW LEVEL SECURITY;

-- Profiles policies
CREATE POLICY "Users can view own profile" ON profiles
  FOR SELECT USING (auth.uid() = id);

CREATE POLICY "Users can update own profile" ON profiles
  FOR UPDATE USING (auth.uid() = id);

CREATE POLICY "Users can insert own profile" ON profiles
  FOR INSERT WITH CHECK (auth.uid() = id);

-- CV data policies
CREATE POLICY "Users can view own CV data" ON cv_data
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own CV data" ON cv_data
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own CV data" ON cv_data
  FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own CV data" ON cv_data
  FOR DELETE USING (auth.uid() = user_id);

-- Generated content policies
CREATE POLICY "Users can view own generated content" ON generated_content
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own generated content" ON generated_content
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own generated content" ON generated_content
  FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own generated content" ON generated_content
  FOR DELETE USING (auth.uid() = user_id);
```

### 4. API Routes Architecture

#### Authentication Routes
```typescript
// app/api/auth/login/route.ts
import { createClient } from '@/utils/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

export async function POST(request: NextRequest) {
  try {
    const { email, password } = await request.json()
    const supabase = await createClient()

    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password,
    })

    if (error) {
      return NextResponse.json(
        { error: error.message },
        { status: 400 }
      )
    }

    return NextResponse.json({
      user: data.user,
      session: data.session
    })
  } catch (error) {
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}

// app/api/auth/register/route.ts
export async function POST(request: NextRequest) {
  try {
    const { email, password, fullName } = await request.json()
    const supabase = await createClient()

    const { data, error } = await supabase.auth.signUp({
      email,
      password,
      options: {
        data: {
          full_name: fullName,
        }
      }
    })

    if (error) {
      return NextResponse.json(
        { error: error.message },
        { status: 400 }
      )
    }

    return NextResponse.json({
      user: data.user,
      session: data.session
    })
  } catch (error) {
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}

// app/api/auth/logout/route.ts
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()
    await supabase.auth.signOut()
    
    return NextResponse.json({ success: true })
  } catch (error) {
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}
```

#### User Management Routes
```typescript
// app/api/user/profile/route.ts
import { prisma } from '@/lib/prisma'

export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()
    const { data: { user } } = await supabase.auth.getUser()

    if (!user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      )
    }

    // Using Prisma for type-safe database operations
    const profile = await prisma.profile.findUnique({
      where: { userId: user.id },
      include: {
        userSessions: {
          where: { expiresAt: { gt: new Date() } },
          orderBy: { lastActivity: 'desc' },
          take: 5
        },
        userActivities: {
          orderBy: { createdAt: 'desc' },
          take: 10
        },
        cvData: {
          orderBy: { createdAt: 'desc' },
          take: 5
        },
        generatedContent: {
          orderBy: { createdAt: 'desc' },
          take: 10
        }
      }
    })

    if (!profile) {
      return NextResponse.json(
        { error: 'Profile not found' },
        { status: 404 }
      )
    }

    return NextResponse.json({ profile })
  } catch (error) {
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}

export async function PUT(request: NextRequest) {
  try {
    const supabase = await createClient()
    const { data: { user } } = await supabase.auth.getUser()

    if (!user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      )
    }

    const updates = await request.json()
    
    // Using Prisma for type-safe database operations
    const profile = await prisma.profile.update({
      where: { userId: user.id },
      data: {
        ...updates,
        updatedAt: new Date()
      },
      include: {
        userSessions: {
          where: { expiresAt: { gt: new Date() } },
          orderBy: { lastActivity: 'desc' },
          take: 5
        },
        userActivities: {
          orderBy: { createdAt: 'desc' },
          take: 10
        }
      }
    })

    return NextResponse.json({ profile })
  } catch (error) {
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}
```

### 5. State Management Architecture

#### Authentication Context with Anonymous Support
```typescript
// contexts/auth-context.tsx
interface AuthContextType {
  user: User | null
  profile: UserProfile | null
  isLoading: boolean
  isAnonymous: boolean
  signIn: (email: string, password: string) => Promise<void>
  signUp: (email: string, password: string, fullName: string) => Promise<void>
  signOut: () => Promise<void>
  updateProfile: (updates: Partial<UserProfile>) => Promise<void>
  refreshProfile: () => Promise<void>
  requireAuth: (action: string, data?: any) => Promise<boolean>
  showAuthModal: (mode?: 'login' | 'signup' | 'both', preserveData?: any) => void
}

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null)
  const [profile, setProfile] = useState<UserProfile | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [isAnonymous, setIsAnonymous] = useState(true)
  const [authModalOpen, setAuthModalOpen] = useState(false)
  const [authModalMode, setAuthModalMode] = useState<'login' | 'signup' | 'both'>('both')
  const [preservedData, setPreservedData] = useState<any>(null)
  const supabase = createClient()

  useEffect(() => {
    // Get initial session
    const getInitialSession = async () => {
      const { data: { session } } = await supabase.auth.getSession()
      setUser(session?.user ?? null)
      setIsAnonymous(!session?.user)
      
      if (session?.user) {
        await loadUserProfile(session.user.id)
      }
      
      setIsLoading(false)
    }

    getInitialSession()

    // Listen for auth changes
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      async (event, session) => {
        setUser(session?.user ?? null)
        setIsAnonymous(!session?.user)
        
        if (session?.user) {
          await loadUserProfile(session.user.id)
        } else {
          setProfile(null)
        }
      }
    )

    return () => subscription.unsubscribe()
  }, [])

  const loadUserProfile = async (userId: string) => {
    try {
      // Using Prisma for type-safe database operations
      const profile = await prisma.profile.findUnique({
        where: { userId },
        include: {
          userSessions: {
            where: { expiresAt: { gt: new Date() } },
            orderBy: { lastActivity: 'desc' },
            take: 5
          },
          userActivities: {
            orderBy: { createdAt: 'desc' },
            take: 10
          }
        }
      })

      if (profile) {
        setProfile(profile)
      }
    } catch (error) {
      console.error('Error loading profile:', error)
    }
  }

  const signIn = async (email: string, password: string) => {
    const { error } = await supabase.auth.signInWithPassword({
      email,
      password,
    })
    if (error) throw error
  }

  const signUp = async (email: string, password: string, fullName: string) => {
    const { error } = await supabase.auth.signUp({
      email,
      password,
      options: {
        data: {
          full_name: fullName,
        }
      }
    })
    if (error) throw error
  }

  const signOut = async () => {
    const { error } = await supabase.auth.signOut()
    if (error) throw error
  }

  const updateProfile = async (updates: Partial<UserProfile>) => {
    if (!user) throw new Error('No user logged in')
    
    // Using Prisma for type-safe database operations
    const updatedProfile = await prisma.profile.update({
      where: { userId: user.id },
      data: {
        ...updates,
        updatedAt: new Date()
      },
      include: {
        userSessions: {
          where: { expiresAt: { gt: new Date() } },
          orderBy: { lastActivity: 'desc' },
          take: 5
        },
        userActivities: {
          orderBy: { createdAt: 'desc' },
          take: 10
        }
      }
    })

    setProfile(updatedProfile)
  }

  const refreshProfile = async () => {
    if (!user) return
    await loadUserProfile(user.id)
  }

  const requireAuth = async (action: string, data?: any): Promise<boolean> => {
    if (user) return true
    
    // Show auth modal with preserved data
    setPreservedData({ action, data })
    setAuthModalOpen(true)
    return false
  }

  const showAuthModal = (mode: 'login' | 'signup' | 'both' = 'both', preserveData?: any) => {
    setAuthModalMode(mode)
    setPreservedData(preserveData)
    setAuthModalOpen(true)
  }

  const handleAuthSuccess = async (authenticatedUser: User) => {
    setAuthModalOpen(false)
    setPreservedData(null)
    
    // If there was preserved data, trigger the original action
    if (preservedData?.action) {
      // Handle the preserved action (e.g., CV analysis)
      await handlePreservedAction(authenticatedUser, preservedData)
    }
  }

  const handlePreservedAction = async (user: User, data: any) => {
    // Restore any preserved form data and trigger the original action
    if (data.action === 'cv_analysis' && data.data) {
      // Trigger CV analysis with preserved data
      // This would be implemented in the main application component
    }
  }

  return (
    <AuthContext.Provider value={{
      user,
      profile,
      isLoading,
      isAnonymous,
      signIn,
      signUp,
      signOut,
      updateProfile,
      refreshProfile,
      requireAuth,
      showAuthModal
    }}>
      {children}
      
      {/* Authentication Modal */}
      <AuthModal
        isOpen={authModalOpen}
        onClose={() => setAuthModalOpen(false)}
        onSuccess={handleAuthSuccess}
        mode={authModalMode}
        preserveData={preservedData}
      />
    </AuthContext.Provider>
  )
}
```

### 6. Security Architecture

#### Input Validation with Configurable Email Validation
```typescript
// lib/validation/auth-validation.ts
import { z } from 'zod'

// Email validation configuration
const emailValidationConfig = {
  requireVerification: process.env.REQUIRE_EMAIL_VERIFICATION === 'true',
  strictValidation: process.env.EMAIL_VALIDATION_STRICT === 'true',
  allowDisposable: process.env.ALLOW_DISPOSABLE_EMAILS === 'true',
}

// Disposable email domains (configurable)
const disposableEmailDomains = [
  '10minutemail.com', 'tempmail.org', 'guerrillamail.com',
  'mailinator.com', 'yopmail.com', 'temp-mail.org'
]

// Email validation function
const createEmailValidation = () => {
  let emailSchema = z.string()
  
  if (emailValidationConfig.strictValidation) {
    emailSchema = emailSchema
      .email('Invalid email address')
      .refine((email) => {
        // Check for disposable emails if not allowed
        if (!emailValidationConfig.allowDisposable) {
          const domain = email.split('@')[1]?.toLowerCase()
          return !disposableEmailDomains.includes(domain)
        }
        return true
      }, 'Disposable email addresses are not allowed')
      .refine((email) => {
        // Additional domain validation
        const domain = email.split('@')[1]
        return domain && domain.length > 0
      }, 'Invalid email domain')
  } else {
    emailSchema = emailSchema.email('Invalid email address')
  }
  
  return emailSchema
}

export const loginSchema = z.object({
  email: createEmailValidation(),
  password: z.string().min(8, 'Password must be at least 8 characters'),
})

export const signupSchema = z.object({
  email: createEmailValidation(),
  password: z.string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/, 'Password must contain uppercase, lowercase, and number'),
  confirmPassword: z.string(),
  fullName: z.string().min(2, 'Full name must be at least 2 characters'),
  acceptTerms: z.boolean().refine(val => val === true, 'You must accept the terms'),
}).refine(data => data.password === data.confirmPassword, {
  message: "Passwords don't match",
  path: ["confirmPassword"],
})

// Environment-based validation helper
export const getEmailValidationConfig = () => emailValidationConfig

export const profileUpdateSchema = z.object({
  fullName: z.string().min(2, 'Full name must be at least 2 characters').optional(),
  username: z.string().min(3, 'Username must be at least 3 characters').optional(),
  preferences: z.object({
    language: z.string().optional(),
    timezone: z.string().optional(),
    notifications: z.object({
      email: z.boolean().optional(),
      push: z.boolean().optional(),
      marketing: z.boolean().optional(),
    }).optional(),
  }).optional(),
})
```

#### Rate Limiting
```typescript
// lib/rate-limiting.ts
import { Ratelimit } from '@upstash/ratelimit'
import { Redis } from '@upstash/redis'

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!,
})

export const ratelimit = new Ratelimit({
  redis: redis,
  limiter: Ratelimit.slidingWindow(10, '1 m'), // 10 requests per minute
})

export const authRatelimit = new Ratelimit({
  redis: redis,
  limiter: Ratelimit.slidingWindow(5, '1 m'), // 5 auth requests per minute
})
```

### 7. File Storage Architecture

#### Avatar Upload
```typescript
// lib/storage/avatar-upload.ts
export async function uploadAvatar(userId: string, file: File) {
  const supabase = createClient()
  
  // Validate file
  if (!file.type.startsWith('image/')) {
    throw new Error('File must be an image')
  }
  
  if (file.size > 5 * 1024 * 1024) { // 5MB limit
    throw new Error('File size must be less than 5MB')
  }

  // Generate unique filename
  const fileExt = file.name.split('.').pop()
  const fileName = `${userId}-${Date.now()}.${fileExt}`

  // Upload to Supabase Storage
  const { data, error } = await supabase.storage
    .from('avatars')
    .upload(fileName, file, {
      cacheControl: '3600',
      upsert: false
    })

  if (error) throw error

  // Get public URL
  const { data: { publicUrl } } = supabase.storage
    .from('avatars')
    .getPublicUrl(fileName)

  return publicUrl
}
```

### 8. Error Handling Architecture

#### Error Types
```typescript
// lib/errors/auth-errors.ts
export class AuthError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number = 400
  ) {
    super(message)
    this.name = 'AuthError'
  }
}

export class ValidationError extends AuthError {
  constructor(message: string, public field?: string) {
    super(message, 'VALIDATION_ERROR', 400)
  }
}

export class AuthenticationError extends AuthError {
  constructor(message: string = 'Authentication failed') {
    super(message, 'AUTHENTICATION_ERROR', 401)
  }
}

export class AuthorizationError extends AuthError {
  constructor(message: string = 'Access denied') {
    super(message, 'AUTHORIZATION_ERROR', 403)
  }
}
```

#### Error Handler
```typescript
// lib/error-handler.ts
export function handleAuthError(error: any): AuthError {
  if (error instanceof AuthError) {
    return error
  }

  // Supabase auth errors
  if (error.message?.includes('Invalid login credentials')) {
    return new AuthenticationError('Invalid email or password')
  }

  if (error.message?.includes('User already registered')) {
    return new ValidationError('An account with this email already exists')
  }

  if (error.message?.includes('Password should be at least')) {
    return new ValidationError('Password must be at least 6 characters')
  }

  // Generic error
  return new AuthError(
    error.message || 'An unexpected error occurred',
    'UNKNOWN_ERROR',
    500
  )
}
```

## Performance Architecture

### Caching Strategy
```typescript
// lib/cache/user-cache.ts
import { Redis } from '@upstash/redis'

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!,
})

export async function getCachedProfile(userId: string) {
  const cached = await redis.get(`profile:${userId}`)
  if (cached) return JSON.parse(cached as string)
  return null
}

export async function setCachedProfile(userId: string, profile: UserProfile) {
  await redis.setex(`profile:${userId}`, 3600, JSON.stringify(profile)) // 1 hour cache
}

export async function invalidateProfileCache(userId: string) {
  await redis.del(`profile:${userId}`)
}
```

### Database Optimization
```sql
-- Indexes for performance
CREATE INDEX idx_profiles_email ON profiles(email);
CREATE INDEX idx_profiles_username ON profiles(username);
CREATE INDEX idx_cv_data_user_id ON cv_data(user_id);
CREATE INDEX idx_cv_data_created_at ON cv_data(created_at);
CREATE INDEX idx_generated_content_user_id ON generated_content(user_id);
CREATE INDEX idx_generated_content_type ON generated_content(content_type);
CREATE INDEX idx_user_activity_user_id ON user_activity(user_id);
CREATE INDEX idx_user_activity_created_at ON user_activity(created_at);

-- Partial indexes for active sessions
CREATE INDEX idx_user_sessions_active ON user_sessions(user_id) 
WHERE expires_at > NOW();
```

## Monitoring & Analytics

### User Activity Tracking
```typescript
// lib/analytics/user-activity.ts
import { prisma } from '@/lib/prisma'

export async function trackUserActivity(
  userId: string,
  action: string,
  metadata: Record<string, any> = {},
  request?: NextRequest
) {
  // Using Prisma for type-safe database operations
  await prisma.userActivity.create({
    data: {
      userId,
      action,
      metadata,
      ipAddress: request?.ip,
      userAgent: request?.headers.get('user-agent'),
    }
  })
}

// Usage examples
await trackUserActivity(user.id, 'login', { method: 'email' })
await trackUserActivity(user.id, 'cv_upload', { filename: file.name, size: file.size })
await trackUserActivity(user.id, 'content_generated', { type: 'cover_letter', language: 'en' })
```

### Prisma ORM Benefits

#### Type Safety
- **Compile-time Type Checking**: All database operations are type-safe
- **Auto-generated Types**: Prisma generates TypeScript types from schema
- **IntelliSense Support**: Full IDE support with autocomplete and error detection

#### Database Operations
- **Query Builder**: Intuitive API for complex queries
- **Relations**: Easy handling of database relationships
- **Transactions**: Built-in support for database transactions
- **Migrations**: Version-controlled database schema changes

#### Performance Features
- **Connection Pooling**: Efficient database connection management
- **Query Optimization**: Automatic query optimization
- **Caching**: Built-in query result caching
- **Batch Operations**: Efficient bulk operations

### Performance Monitoring
```typescript
// lib/monitoring/performance.ts
export function measureAuthPerformance<T>(
  operation: string,
  fn: () => Promise<T>
): Promise<T> {
  const start = Date.now()
  
  return fn().finally(() => {
    const duration = Date.now() - start
    console.log(`Auth operation '${operation}' took ${duration}ms`)
    
    // Send to monitoring service
    if (duration > 1000) {
      console.warn(`Slow auth operation: ${operation} (${duration}ms)`)
    }
  })
}
```

## Deployment Architecture

### Environment Configuration
```typescript
// lib/config/auth-config.ts
export const authConfig = {
  supabase: {
    url: process.env.NEXT_PUBLIC_SUPABASE_URL!,
    anonKey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    serviceRoleKey: process.env.SUPABASE_SERVICE_ROLE_KEY!,
  },
  prisma: {
    databaseUrl: process.env.DATABASE_URL!,
    logLevel: process.env.NODE_ENV === 'development' ? 'query' : 'error',
  },
  security: {
    sessionTimeout: 24 * 60 * 60 * 1000, // 24 hours
    refreshThreshold: 60 * 60 * 1000, // 1 hour
    maxLoginAttempts: 5,
    lockoutDuration: 15 * 60 * 1000, // 15 minutes
  },
  storage: {
    maxFileSize: 5 * 1024 * 1024, // 5MB
    allowedTypes: ['image/jpeg', 'image/png', 'image/webp'],
    bucketName: 'avatars',
  },
  rateLimiting: {
    authRequests: 5, // per minute
    apiRequests: 100, // per minute
    windowMs: 60 * 1000, // 1 minute
  },
}
```

### Health Checks
```typescript
// app/api/health/auth/route.ts
import { prisma } from '@/lib/prisma'

export async function GET() {
  try {
    const supabase = await createClient()
    
    // Test Supabase connection
    const { data, error } = await supabase
      .from('profiles')
      .select('count')
      .limit(1)
    
    if (error) throw error
    
    // Test Prisma connection
    await prisma.$queryRaw`SELECT 1`
    
    return NextResponse.json({
      status: 'healthy',
      supabase: 'connected',
      prisma: 'connected',
      database: 'connected',
      timestamp: new Date().toISOString(),
    })
  } catch (error) {
    return NextResponse.json(
      {
        status: 'unhealthy',
        error: error.message,
        timestamp: new Date().toISOString(),
      },
      { status: 500 }
    )
  }
}
```

This authentication feature architecture provides a comprehensive, scalable, and secure foundation for implementing user authentication in JobBooster 2025, leveraging Supabase's powerful backend-as-a-service capabilities combined with Prisma ORM for type-safe database operations, while maintaining full control over the user experience and data security.